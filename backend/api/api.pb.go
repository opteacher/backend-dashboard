// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: backend/api/api.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/bilibili/kratos/tool/protobuf/pkg/extensions/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SpcSymbol int32

const (
	SpcSymbol_NONE      SpcSymbol = 0
	SpcSymbol_BLOCK_IN  SpcSymbol = 1
	SpcSymbol_BLOCK_OUT SpcSymbol = 2
	SpcSymbol_END       SpcSymbol = 4
)

var SpcSymbol_name = map[int32]string{
	0: "NONE",
	1: "BLOCK_IN",
	2: "BLOCK_OUT",
	4: "END",
}

var SpcSymbol_value = map[string]int32{
	"NONE":      0,
	"BLOCK_IN":  1,
	"BLOCK_OUT": 2,
	"END":       4,
}

func (x SpcSymbol) String() string {
	return proto.EnumName(SpcSymbol_name, int32(x))
}

func (SpcSymbol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{0}
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type NumberID struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NumberID) Reset()         { *m = NumberID{} }
func (m *NumberID) String() string { return proto.CompactTextString(m) }
func (*NumberID) ProtoMessage()    {}
func (*NumberID) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{1}
}
func (m *NumberID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumberID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberID.Merge(m, src)
}
func (m *NumberID) XXX_Size() int {
	return m.Size()
}
func (m *NumberID) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberID.DiscardUnknown(m)
}

var xxx_messageInfo_NumberID proto.InternalMessageInfo

type NameID struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NameID) Reset()         { *m = NameID{} }
func (m *NameID) String() string { return proto.CompactTextString(m) }
func (*NameID) ProtoMessage()    {}
func (*NameID) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{2}
}
func (m *NameID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NameID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameID.Merge(m, src)
}
func (m *NameID) XXX_Size() int {
	return m.Size()
}
func (m *NameID) XXX_DiscardUnknown() {
	xxx_messageInfo_NameID.DiscardUnknown(m)
}

var xxx_messageInfo_NameID proto.InternalMessageInfo

type TypeIden struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypeIden) Reset()         { *m = TypeIden{} }
func (m *TypeIden) String() string { return proto.CompactTextString(m) }
func (*TypeIden) ProtoMessage()    {}
func (*TypeIden) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{3}
}
func (m *TypeIden) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeIden) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeIden.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeIden) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeIden.Merge(m, src)
}
func (m *TypeIden) XXX_Size() int {
	return m.Size()
}
func (m *TypeIden) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeIden.DiscardUnknown(m)
}

var xxx_messageInfo_TypeIden proto.InternalMessageInfo

type NameArray struct {
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NameArray) Reset()         { *m = NameArray{} }
func (m *NameArray) String() string { return proto.CompactTextString(m) }
func (*NameArray) ProtoMessage()    {}
func (*NameArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{4}
}
func (m *NameArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NameArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameArray.Merge(m, src)
}
func (m *NameArray) XXX_Size() int {
	return m.Size()
}
func (m *NameArray) XXX_DiscardUnknown() {
	xxx_messageInfo_NameArray.DiscardUnknown(m)
}

var xxx_messageInfo_NameArray proto.InternalMessageInfo

type Prop struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Prop) Reset()         { *m = Prop{} }
func (m *Prop) String() string { return proto.CompactTextString(m) }
func (*Prop) ProtoMessage()    {}
func (*Prop) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{5}
}
func (m *Prop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prop.Merge(m, src)
}
func (m *Prop) XXX_Size() int {
	return m.Size()
}
func (m *Prop) XXX_DiscardUnknown() {
	xxx_messageInfo_Prop.DiscardUnknown(m)
}

var xxx_messageInfo_Prop proto.InternalMessageInfo

type Model struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" orm:",UNIQUE_KEY|NOT_NULL|PRIMARY_KEY|COMMENT(模块名)"`
	Props                []*Prop  `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty"`
	Methods              []string `protobuf:"bytes,4,rep,name=methods,proto3" json:"methods,omitempty"`
	Type                 string   `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty" orm:",DEFAULT('model')|COMMENT(种类：模块、结构)"`
	Model                string   `protobuf:"bytes,6,opt,name=model,proto3" json:"model,omitempty" orm:",FOREIGN_KEY(models.name)|COMMENT(关联模块)"`
	X                    int32    `protobuf:"varint,7,opt,name=x,proto3" json:"x"`
	Y                    int32    `protobuf:"varint,8,opt,name=y,proto3" json:"y"`
	Width                int32    `protobuf:"varint,9,opt,name=width,proto3" json:"width,omitempty"`
	Height               int32    `protobuf:"varint,10,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{6}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type ModelArray struct {
	Models               []*Model `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelArray) Reset()         { *m = ModelArray{} }
func (m *ModelArray) String() string { return proto.CompactTextString(m) }
func (*ModelArray) ProtoMessage()    {}
func (*ModelArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{7}
}
func (m *ModelArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelArray.Merge(m, src)
}
func (m *ModelArray) XXX_Size() int {
	return m.Size()
}
func (m *ModelArray) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelArray.DiscardUnknown(m)
}

var xxx_messageInfo_ModelArray proto.InternalMessageInfo

type DaoGroup struct {
	Name                 string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" orm:",PRIMARY_KEY|UNIQUE_KEY"`
	Category             string          `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty" orm:",COMMENT(类别)"`
	Implement            string          `protobuf:"bytes,3,opt,name=implement,proto3" json:"implement,omitempty" orm:",COMMENT(实现方案)"`
	Interfaces           []*DaoInterface `protobuf:"bytes,4,rep,name=interfaces,proto3" json:"interfaces,omitempty" orm:"*"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DaoGroup) Reset()         { *m = DaoGroup{} }
func (m *DaoGroup) String() string { return proto.CompactTextString(m) }
func (*DaoGroup) ProtoMessage()    {}
func (*DaoGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{8}
}
func (m *DaoGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoGroup.Merge(m, src)
}
func (m *DaoGroup) XXX_Size() int {
	return m.Size()
}
func (m *DaoGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DaoGroup proto.InternalMessageInfo

type DaoGroupArray struct {
	Groups               []*DaoGroup `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DaoGroupArray) Reset()         { *m = DaoGroupArray{} }
func (m *DaoGroupArray) String() string { return proto.CompactTextString(m) }
func (*DaoGroupArray) ProtoMessage()    {}
func (*DaoGroupArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{9}
}
func (m *DaoGroupArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoGroupArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoGroupArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoGroupArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoGroupArray.Merge(m, src)
}
func (m *DaoGroupArray) XXX_Size() int {
	return m.Size()
}
func (m *DaoGroupArray) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoGroupArray.DiscardUnknown(m)
}

var xxx_messageInfo_DaoGroupArray proto.InternalMessageInfo

type DaoConfig struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" orm:",PRIMARY_KEY|COMMENT(键名)"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" orm:",COMMENT(键值（按JSON字符串存储）)"`
	Implement            string   `protobuf:"bytes,3,opt,name=implement,proto3" json:"implement,omitempty" orm:",PRIMARY_KEY|COMMENT(所属实现方案)"`
	Desc                 string   `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty" orm:",COMMENT(备注)"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoConfig) Reset()         { *m = DaoConfig{} }
func (m *DaoConfig) String() string { return proto.CompactTextString(m) }
func (*DaoConfig) ProtoMessage()    {}
func (*DaoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{10}
}
func (m *DaoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoConfig.Merge(m, src)
}
func (m *DaoConfig) XXX_Size() int {
	return m.Size()
}
func (m *DaoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DaoConfig proto.InternalMessageInfo

type DaoInterface struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" orm:",|COMMENT(接口名、函数名)"`
	Category             string   `protobuf:"bytes,2,opt,name=category,proto3" json:"category,omitempty"`
	Params               []*Prop  `protobuf:"bytes,3,rep,name=params,proto3" json:"params,omitempty" orm:",|COMMENT(输入数据)"`
	Returns              []string `protobuf:"bytes,4,rep,name=returns,proto3" json:"returns,omitempty" orm:",|COMMENT(输出数据)"`
	Group                string   `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty" orm:",FOREIGN_KEY(dao_groups.name)|COMMENT(所属DAO组)"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaoInterface) Reset()         { *m = DaoInterface{} }
func (m *DaoInterface) String() string { return proto.CompactTextString(m) }
func (*DaoInterface) ProtoMessage()    {}
func (*DaoInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{11}
}
func (m *DaoInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaoInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaoInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DaoInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaoInterface.Merge(m, src)
}
func (m *DaoInterface) XXX_Size() int {
	return m.Size()
}
func (m *DaoInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_DaoInterface.DiscardUnknown(m)
}

var xxx_messageInfo_DaoInterface proto.InternalMessageInfo

type ExpOptions struct {
	Name                 string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string    `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	RoutePrefix          string    `protobuf:"bytes,3,opt,name=routePrefix,proto3" json:"routePrefix,omitempty"`
	IsMicoServ           bool      `protobuf:"varint,4,opt,name=isMicoServ,proto3" json:"isMicoServ,omitempty"`
	Database             *Database `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ExpOptions) Reset()         { *m = ExpOptions{} }
func (m *ExpOptions) String() string { return proto.CompactTextString(m) }
func (*ExpOptions) ProtoMessage()    {}
func (*ExpOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{12}
}
func (m *ExpOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpOptions.Merge(m, src)
}
func (m *ExpOptions) XXX_Size() int {
	return m.Size()
}
func (m *ExpOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ExpOptions proto.InternalMessageInfo

type Database struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Host                 string   `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	Port                 string   `protobuf:"bytes,4,opt,name=port,proto3" json:"port,omitempty"`
	Username             string   `protobuf:"bytes,5,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,6,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Database) Reset()         { *m = Database{} }
func (m *Database) String() string { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()    {}
func (*Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{13}
}
func (m *Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Database.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Database.Merge(m, src)
}
func (m *Database) XXX_Size() int {
	return m.Size()
}
func (m *Database) XXX_DiscardUnknown() {
	xxx_messageInfo_Database.DiscardUnknown(m)
}

var xxx_messageInfo_Database proto.InternalMessageInfo

type UrlResp struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrlResp) Reset()         { *m = UrlResp{} }
func (m *UrlResp) String() string { return proto.CompactTextString(m) }
func (*UrlResp) ProtoMessage()    {}
func (*UrlResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{14}
}
func (m *UrlResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrlResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrlResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrlResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrlResp.Merge(m, src)
}
func (m *UrlResp) XXX_Size() int {
	return m.Size()
}
func (m *UrlResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UrlResp.DiscardUnknown(m)
}

var xxx_messageInfo_UrlResp proto.InternalMessageInfo

// 所有事务流都是函数调用，而且所有的函数返回值都是err结尾
type OperStep struct {
	Id                   int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OperKey              string            `protobuf:"bytes,2,opt,name=operKey,proto3" json:"operKey,omitempty" orm:",NOT_NULL|PRIMARY_KEY"`
	Requires             []string          `protobuf:"bytes,3,rep,name=requires,proto3" json:"requires,omitempty"`
	Desc                 string            `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	Inputs               map[string]string `protobuf:"bytes,5,rep,name=inputs,proto3" json:"inputs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Outputs              []string          `protobuf:"bytes,6,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Code                 string            `protobuf:"bytes,9,opt,name=code,proto3" json:"code,omitempty"`
	ApiName              string            `protobuf:"bytes,10,opt,name=apiName,proto3" json:"apiName,omitempty" orm:",FOREIGN_KEY(api_infos.name)"`
	Symbol               SpcSymbol         `protobuf:"varint,11,opt,name=symbol,proto3,enum=backend.manager.service.v1.SpcSymbol" json:"symbol,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OperStep) Reset()         { *m = OperStep{} }
func (m *OperStep) String() string { return proto.CompactTextString(m) }
func (*OperStep) ProtoMessage()    {}
func (*OperStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{15}
}
func (m *OperStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperStep.Merge(m, src)
}
func (m *OperStep) XXX_Size() int {
	return m.Size()
}
func (m *OperStep) XXX_DiscardUnknown() {
	xxx_messageInfo_OperStep.DiscardUnknown(m)
}

var xxx_messageInfo_OperStep proto.InternalMessageInfo

type ApiInfo struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" orm:",NOT_NULL|PRIMARY_KEY"`
	Model                string            `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	Table                string            `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	Params               map[string]string `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Route                string            `protobuf:"bytes,5,opt,name=route,proto3" json:"route,omitempty"`
	Method               string            `protobuf:"bytes,6,opt,name=method,proto3" json:"method,omitempty"`
	Returns              []string          `protobuf:"bytes,7,rep,name=returns,proto3" json:"returns,omitempty"`
	Steps                []*OperStep       `protobuf:"bytes,8,rep,name=steps,proto3" json:"steps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ApiInfo) Reset()         { *m = ApiInfo{} }
func (m *ApiInfo) String() string { return proto.CompactTextString(m) }
func (*ApiInfo) ProtoMessage()    {}
func (*ApiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{16}
}
func (m *ApiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiInfo.Merge(m, src)
}
func (m *ApiInfo) XXX_Size() int {
	return m.Size()
}
func (m *ApiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ApiInfo proto.InternalMessageInfo

type ApiInfoArray struct {
	Infos                []*ApiInfo `protobuf:"bytes,1,rep,name=infos,proto3" json:"infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ApiInfoArray) Reset()         { *m = ApiInfoArray{} }
func (m *ApiInfoArray) String() string { return proto.CompactTextString(m) }
func (*ApiInfoArray) ProtoMessage()    {}
func (*ApiInfoArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{17}
}
func (m *ApiInfoArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApiInfoArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApiInfoArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApiInfoArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApiInfoArray.Merge(m, src)
}
func (m *ApiInfoArray) XXX_Size() int {
	return m.Size()
}
func (m *ApiInfoArray) XXX_DiscardUnknown() {
	xxx_messageInfo_ApiInfoArray.DiscardUnknown(m)
}

var xxx_messageInfo_ApiInfoArray proto.InternalMessageInfo

type OperStepArray struct {
	Steps                []*OperStep `protobuf:"bytes,1,rep,name=steps,proto3" json:"steps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *OperStepArray) Reset()         { *m = OperStepArray{} }
func (m *OperStepArray) String() string { return proto.CompactTextString(m) }
func (*OperStepArray) ProtoMessage()    {}
func (*OperStepArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{18}
}
func (m *OperStepArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperStepArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperStepArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperStepArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperStepArray.Merge(m, src)
}
func (m *OperStepArray) XXX_Size() int {
	return m.Size()
}
func (m *OperStepArray) XXX_DiscardUnknown() {
	xxx_messageInfo_OperStepArray.DiscardUnknown(m)
}

var xxx_messageInfo_OperStepArray proto.InternalMessageInfo

type SymbolsResp struct {
	Values               map[string]int32 `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Names                map[int32]string `protobuf:"bytes,2,rep,name=names,proto3" json:"names,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SymbolsResp) Reset()         { *m = SymbolsResp{} }
func (m *SymbolsResp) String() string { return proto.CompactTextString(m) }
func (*SymbolsResp) ProtoMessage()    {}
func (*SymbolsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{19}
}
func (m *SymbolsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SymbolsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SymbolsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SymbolsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymbolsResp.Merge(m, src)
}
func (m *SymbolsResp) XXX_Size() int {
	return m.Size()
}
func (m *SymbolsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SymbolsResp.DiscardUnknown(m)
}

var xxx_messageInfo_SymbolsResp proto.InternalMessageInfo

type StepReqs struct {
	Index                int32     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	OperStep             *OperStep `protobuf:"bytes,2,opt,name=operStep,proto3" json:"operStep,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StepReqs) Reset()         { *m = StepReqs{} }
func (m *StepReqs) String() string { return proto.CompactTextString(m) }
func (*StepReqs) ProtoMessage()    {}
func (*StepReqs) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{20}
}
func (m *StepReqs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepReqs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepReqs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepReqs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepReqs.Merge(m, src)
}
func (m *StepReqs) XXX_Size() int {
	return m.Size()
}
func (m *StepReqs) XXX_DiscardUnknown() {
	xxx_messageInfo_StepReqs.DiscardUnknown(m)
}

var xxx_messageInfo_StepReqs proto.InternalMessageInfo

type DelStepReqs struct {
	ApiName              string   `protobuf:"bytes,1,opt,name=apiName,proto3" json:"apiName,omitempty"`
	StepId               int32    `protobuf:"varint,2,opt,name=stepId,proto3" json:"stepId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelStepReqs) Reset()         { *m = DelStepReqs{} }
func (m *DelStepReqs) String() string { return proto.CompactTextString(m) }
func (*DelStepReqs) ProtoMessage()    {}
func (*DelStepReqs) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{21}
}
func (m *DelStepReqs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelStepReqs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelStepReqs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelStepReqs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelStepReqs.Merge(m, src)
}
func (m *DelStepReqs) XXX_Size() int {
	return m.Size()
}
func (m *DelStepReqs) XXX_DiscardUnknown() {
	xxx_messageInfo_DelStepReqs.DiscardUnknown(m)
}

var xxx_messageInfo_DelStepReqs proto.InternalMessageInfo

type SymbolID struct {
	Symbol               string   `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SymbolID) Reset()         { *m = SymbolID{} }
func (m *SymbolID) String() string { return proto.CompactTextString(m) }
func (*SymbolID) ProtoMessage()    {}
func (*SymbolID) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{22}
}
func (m *SymbolID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SymbolID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SymbolID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SymbolID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SymbolID.Merge(m, src)
}
func (m *SymbolID) XXX_Size() int {
	return m.Size()
}
func (m *SymbolID) XXX_DiscardUnknown() {
	xxx_messageInfo_SymbolID.DiscardUnknown(m)
}

var xxx_messageInfo_SymbolID proto.InternalMessageInfo

type Link struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Symbol               string   `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty" orm:",NOT_NULL|PRIMARY_KEY|UNIQUE_KEY"`
	Mname1               string   `protobuf:"bytes,3,opt,name=mname1,proto3" json:"mname1,omitempty" orm:",FOREIGN_KEY(model1:models.name)"`
	Mnumber1             int32    `protobuf:"varint,4,opt,name=mnumber1,proto3" json:"mnumber1"`
	Mname2               string   `protobuf:"bytes,5,opt,name=mname2,proto3" json:"mname2,omitempty" orm:",FOREIGN_KEY(model2:models.name)"`
	Mnumber2             int32    `protobuf:"varint,6,opt,name=mnumber2,proto3" json:"mnumber2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{23}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

type LinkArray struct {
	Links                []*Link  `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinkArray) Reset()         { *m = LinkArray{} }
func (m *LinkArray) String() string { return proto.CompactTextString(m) }
func (*LinkArray) ProtoMessage()    {}
func (*LinkArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_65b4dc72532dac7d, []int{24}
}
func (m *LinkArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkArray.Merge(m, src)
}
func (m *LinkArray) XXX_Size() int {
	return m.Size()
}
func (m *LinkArray) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkArray.DiscardUnknown(m)
}

var xxx_messageInfo_LinkArray proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("backend.manager.service.v1.SpcSymbol", SpcSymbol_name, SpcSymbol_value)
	proto.RegisterType((*Empty)(nil), "backend.manager.service.v1.Empty")
	proto.RegisterType((*NumberID)(nil), "backend.manager.service.v1.NumberID")
	proto.RegisterType((*NameID)(nil), "backend.manager.service.v1.NameID")
	proto.RegisterType((*TypeIden)(nil), "backend.manager.service.v1.TypeIden")
	proto.RegisterType((*NameArray)(nil), "backend.manager.service.v1.NameArray")
	proto.RegisterType((*Prop)(nil), "backend.manager.service.v1.Prop")
	proto.RegisterType((*Model)(nil), "backend.manager.service.v1.Model")
	proto.RegisterType((*ModelArray)(nil), "backend.manager.service.v1.ModelArray")
	proto.RegisterType((*DaoGroup)(nil), "backend.manager.service.v1.DaoGroup")
	proto.RegisterType((*DaoGroupArray)(nil), "backend.manager.service.v1.DaoGroupArray")
	proto.RegisterType((*DaoConfig)(nil), "backend.manager.service.v1.DaoConfig")
	proto.RegisterType((*DaoInterface)(nil), "backend.manager.service.v1.DaoInterface")
	proto.RegisterType((*ExpOptions)(nil), "backend.manager.service.v1.ExpOptions")
	proto.RegisterType((*Database)(nil), "backend.manager.service.v1.Database")
	proto.RegisterType((*UrlResp)(nil), "backend.manager.service.v1.UrlResp")
	proto.RegisterType((*OperStep)(nil), "backend.manager.service.v1.OperStep")
	proto.RegisterMapType((map[string]string)(nil), "backend.manager.service.v1.OperStep.InputsEntry")
	proto.RegisterType((*ApiInfo)(nil), "backend.manager.service.v1.ApiInfo")
	proto.RegisterMapType((map[string]string)(nil), "backend.manager.service.v1.ApiInfo.ParamsEntry")
	proto.RegisterType((*ApiInfoArray)(nil), "backend.manager.service.v1.ApiInfoArray")
	proto.RegisterType((*OperStepArray)(nil), "backend.manager.service.v1.OperStepArray")
	proto.RegisterType((*SymbolsResp)(nil), "backend.manager.service.v1.SymbolsResp")
	proto.RegisterMapType((map[int32]string)(nil), "backend.manager.service.v1.SymbolsResp.NamesEntry")
	proto.RegisterMapType((map[string]int32)(nil), "backend.manager.service.v1.SymbolsResp.ValuesEntry")
	proto.RegisterType((*StepReqs)(nil), "backend.manager.service.v1.StepReqs")
	proto.RegisterType((*DelStepReqs)(nil), "backend.manager.service.v1.DelStepReqs")
	proto.RegisterType((*SymbolID)(nil), "backend.manager.service.v1.SymbolID")
	proto.RegisterType((*Link)(nil), "backend.manager.service.v1.Link")
	proto.RegisterType((*LinkArray)(nil), "backend.manager.service.v1.LinkArray")
}

func init() { proto.RegisterFile("backend/api/api.proto", fileDescriptor_65b4dc72532dac7d) }

var fileDescriptor_65b4dc72532dac7d = []byte{
	// 2319 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x5b, 0x6f, 0x1b, 0xd7,
	0x11, 0xce, 0x52, 0xe2, 0x6d, 0xe8, 0x8b, 0x70, 0x7c, 0x01, 0xc1, 0xb8, 0xa2, 0x7c, 0x9a, 0xd8,
	0x94, 0xec, 0x50, 0x11, 0x9d, 0xb8, 0x91, 0x72, 0x69, 0x44, 0x93, 0x71, 0x58, 0x4b, 0xa4, 0xb3,
	0x92, 0x0a, 0xa4, 0x7d, 0x30, 0x56, 0xe4, 0xb1, 0xb4, 0x30, 0xc9, 0xdd, 0xec, 0x2e, 0x1d, 0x11,
	0xc8, 0x83, 0x9d, 0xd6, 0xb0, 0x5d, 0xd4, 0x8e, 0x11, 0xdf, 0x92, 0x16, 0x75, 0x11, 0xb4, 0x69,
	0x0d, 0xb4, 0x36, 0xec, 0x06, 0x28, 0x9c, 0xda, 0xed, 0x73, 0x1e, 0x0b, 0xf4, 0xa9, 0x2f, 0x44,
	0xeb, 0x84, 0x52, 0x9a, 0x17, 0x03, 0xfc, 0x05, 0xc5, 0xb9, 0xec, 0x45, 0x96, 0x4d, 0xae, 0x10,
	0x03, 0x79, 0x10, 0xb0, 0x67, 0x79, 0x66, 0xe6, 0x9b, 0x99, 0xef, 0xcc, 0xcc, 0x1e, 0xc1, 0xb6,
	0x79, 0xa5, 0x7c, 0x8c, 0xd4, 0x2b, 0xa3, 0x8a, 0xae, 0xd2, 0xbf, 0xb4, 0x6e, 0x68, 0x96, 0x86,
	0x12, 0xe2, 0x75, 0xba, 0xa6, 0xd4, 0x95, 0x05, 0x62, 0xa4, 0x4d, 0x62, 0x1c, 0x57, 0xcb, 0x24,
	0x7d, 0x7c, 0x2c, 0xb1, 0x75, 0x41, 0x5b, 0xd0, 0xd8, 0xb6, 0x51, 0xfa, 0xc4, 0x25, 0x12, 0x3b,
	0x16, 0x34, 0x6d, 0xa1, 0x4a, 0xb8, 0x9e, 0x7a, 0x5d, 0xb3, 0x14, 0x4b, 0xd5, 0xea, 0x26, 0xff,
	0x15, 0x87, 0x21, 0x98, 0xaf, 0xe9, 0x56, 0x13, 0x27, 0x20, 0x52, 0x6c, 0xd4, 0xe6, 0x89, 0x51,
	0xc8, 0xa1, 0x4d, 0x10, 0x50, 0x2b, 0x71, 0x69, 0x48, 0x4a, 0xf5, 0xc9, 0x01, 0xb5, 0x82, 0x77,
	0x40, 0xa8, 0xa8, 0xd4, 0x48, 0x21, 0x87, 0x10, 0xf4, 0xd7, 0x95, 0x1a, 0x61, 0xbf, 0x45, 0x65,
	0xf6, 0x8c, 0x07, 0x21, 0x32, 0xdb, 0xd4, 0x49, 0xa1, 0x42, 0xea, 0xf4, 0x77, 0xab, 0xa9, 0x3b,
	0xbf, 0xd3, 0x67, 0xbc, 0x13, 0xa2, 0x54, 0x7a, 0xd2, 0x30, 0x94, 0x26, 0xda, 0x0a, 0x41, 0x2a,
	0x64, 0xc6, 0xa5, 0xa1, 0xbe, 0x54, 0x54, 0xe6, 0x0b, 0x9c, 0x86, 0xfe, 0xc3, 0x86, 0xa6, 0x3f,
	0x4a, 0xbd, 0xa3, 0x32, 0xe0, 0x51, 0x79, 0xa7, 0x0f, 0x82, 0xd3, 0x5a, 0x85, 0x54, 0x1f, 0x86,
	0x8a, 0xde, 0x12, 0x1a, 0xd8, 0xee, 0xec, 0xab, 0x9d, 0x56, 0x72, 0x5c, 0x33, 0x6a, 0x13, 0x78,
	0xef, 0x5c, 0xb1, 0xf0, 0xd6, 0x5c, 0xfe, 0xc8, 0xa1, 0xfc, 0xdb, 0xef, 0x15, 0x4b, 0xb3, 0x47,
	0x8a, 0x73, 0x53, 0x53, 0xef, 0x1d, 0x96, 0x0b, 0xd3, 0x93, 0xf2, 0xdb, 0xec, 0xe5, 0x81, 0xd2,
	0xf4, 0x74, 0xbe, 0x38, 0x9b, 0x5a, 0xbe, 0xfe, 0x49, 0xfb, 0x37, 0x57, 0xdb, 0x17, 0xce, 0x0d,
	0x63, 0x01, 0x60, 0x3f, 0x04, 0x75, 0x43, 0xd3, 0xcd, 0x78, 0xdf, 0x50, 0x5f, 0x2a, 0x96, 0x19,
	0x4a, 0x3f, 0x3e, 0x05, 0x69, 0xea, 0x85, 0xcc, 0xb7, 0xa3, 0x38, 0x84, 0x6b, 0xc4, 0x5a, 0xd4,
	0x2a, 0x66, 0xbc, 0x9f, 0x39, 0x6b, 0x2f, 0x29, 0x48, 0xe6, 0x52, 0xf0, 0x61, 0x90, 0xb9, 0xfc,
	0x1b, 0x93, 0x73, 0x53, 0xb3, 0xa9, 0xdd, 0x35, 0xea, 0xdc, 0xee, 0x61, 0x07, 0xd5, 0xca, 0x1f,
	0xcf, 0xad, 0xdc, 0xbe, 0xfb, 0xe0, 0xde, 0xaf, 0x38, 0xbc, 0x2f, 0x4f, 0x9c, 0x5c, 0xb9, 0x7b,
	0x71, 0xf9, 0xda, 0xcf, 0x29, 0x48, 0xaa, 0x0a, 0x95, 0x20, 0xc8, 0x64, 0xe2, 0x21, 0xa6, 0x73,
	0xbc, 0xd3, 0x4a, 0xbe, 0xc8, 0x75, 0xbe, 0x51, 0x92, 0xf3, 0x85, 0x83, 0x45, 0xea, 0x64, 0x8a,
	0x6d, 0x31, 0xd3, 0xd4, 0x2d, 0x57, 0x77, 0xfb, 0xd4, 0x67, 0x5f, 0x9f, 0xbc, 0xc4, 0x15, 0x0f,
	0x63, 0x99, 0xeb, 0x41, 0x5b, 0x40, 0x5a, 0x8a, 0x87, 0x87, 0xa4, 0x54, 0x30, 0x1b, 0xfc, 0xa6,
	0x95, 0x94, 0x96, 0x64, 0x69, 0x89, 0xbe, 0x6c, 0xc6, 0x23, 0xee, 0xcb, 0xa6, 0x2c, 0xb1, 0x94,
	0xbe, 0xab, 0x56, 0xac, 0xc5, 0x78, 0x94, 0xfe, 0x20, 0xf3, 0x05, 0xda, 0x0e, 0xa1, 0x45, 0xa2,
	0x2e, 0x2c, 0x5a, 0x71, 0x60, 0xaf, 0xc5, 0x0a, 0x1f, 0x04, 0x60, 0x99, 0xe3, 0x74, 0x18, 0x87,
	0x10, 0xc7, 0xc4, 0xf8, 0x10, 0xcb, 0xec, 0xec, 0x16, 0x5c, 0x26, 0x27, 0x0b, 0x01, 0x7c, 0x21,
	0x00, 0x91, 0x9c, 0xa2, 0x1d, 0x34, 0xb4, 0x86, 0x8e, 0x5e, 0xf4, 0x12, 0x27, 0xbb, 0xb3, 0xd3,
	0x4a, 0x7e, 0x8f, 0x7b, 0xef, 0x4d, 0xb1, 0x4b, 0x01, 0x37, 0xb5, 0x91, 0xb2, 0x62, 0x91, 0x05,
	0xcd, 0x68, 0x0a, 0xc6, 0x24, 0x3a, 0xad, 0xe4, 0x76, 0x2e, 0xea, 0xc4, 0xfe, 0xf6, 0xdd, 0xf6,
	0x99, 0x3f, 0x0d, 0x63, 0xd9, 0xd9, 0x8b, 0x5e, 0x83, 0xa8, 0x5a, 0xd3, 0xab, 0xa4, 0x46, 0xea,
	0x56, 0xbc, 0x8f, 0x09, 0x0e, 0x75, 0x5a, 0xc9, 0x1d, 0xab, 0x05, 0xdb, 0x37, 0xaf, 0xad, 0x9c,
	0xbf, 0xb5, 0x7c, 0xe5, 0xf3, 0xe5, 0x4f, 0xce, 0x0c, 0x63, 0xd9, 0x15, 0x41, 0x73, 0x00, 0x6a,
	0xdd, 0x22, 0xc6, 0x51, 0xa5, 0x4c, 0x38, 0x3b, 0x62, 0x99, 0x54, 0x37, 0xd7, 0x73, 0x8a, 0x56,
	0xb0, 0x05, 0xb2, 0xb1, 0x4e, 0x2b, 0x19, 0x66, 0xa6, 0x46, 0xb0, 0xec, 0x51, 0x84, 0xa7, 0x61,
	0xa3, 0x1d, 0x11, 0x1e, 0xde, 0x57, 0x20, 0xb4, 0x40, 0x57, 0x76, 0x78, 0x9f, 0xe9, 0x61, 0x83,
	0x89, 0xca, 0x42, 0x06, 0x5f, 0x0d, 0x40, 0x34, 0xa7, 0x68, 0x07, 0xb4, 0xfa, 0x51, 0x75, 0x01,
	0x4d, 0xac, 0x0a, 0xf1, 0xae, 0x4e, 0x2b, 0x89, 0xd7, 0x86, 0xd8, 0x76, 0xfd, 0x7f, 0x97, 0x6e,
	0x7a, 0x8f, 0xd0, 0x14, 0x04, 0x8f, 0x2b, 0xd5, 0x86, 0x7d, 0x2c, 0xf7, 0x77, 0x5a, 0xc9, 0xcc,
	0xea, 0x58, 0x51, 0x81, 0x13, 0xf7, 0x1e, 0xdc, 0x3b, 0xb3, 0xfc, 0xcb, 0xb3, 0x3f, 0x9a, 0x29,
	0x15, 0xdb, 0x37, 0xae, 0xae, 0xfc, 0xf9, 0x0f, 0x5f, 0xdd, 0xf9, 0x4b, 0xfb, 0xc6, 0x47, 0xed,
	0xf7, 0xaf, 0x3f, 0xb8, 0x77, 0x96, 0x52, 0x93, 0x29, 0x41, 0x87, 0xd7, 0x46, 0x3f, 0xd3, 0x69,
	0x25, 0xd3, 0x8f, 0x87, 0xb3, 0x7c, 0xf6, 0x44, 0xfb, 0xf6, 0xb5, 0xc7, 0xe7, 0x23, 0x0d, 0xfd,
	0x15, 0x62, 0x96, 0xe3, 0xfd, 0x8f, 0xe3, 0x40, 0xfb, 0xf7, 0xa7, 0x97, 0x3f, 0xbb, 0x4e, 0xfd,
	0xa1, 0xfb, 0xf0, 0xbf, 0x03, 0xb0, 0xc1, 0x9b, 0x12, 0xf4, 0xda, 0xaa, 0xe0, 0x8c, 0x74, 0x5a,
	0xc9, 0x5d, 0x5c, 0x81, 0x0b, 0xe1, 0xfc, 0xa7, 0xed, 0x0f, 0x7e, 0xd7, 0xbe, 0x70, 0xee, 0xcb,
	0x13, 0x27, 0xdb, 0xa7, 0xff, 0xbe, 0x7c, 0xf9, 0x96, 0x37, 0x40, 0x89, 0x87, 0x89, 0xe8, 0x21,
	0xdb, 0x4f, 0x21, 0xa4, 0x2b, 0x86, 0x52, 0xf3, 0x5d, 0x80, 0xbc, 0xfc, 0x77, 0xec, 0x7f, 0xfd,
	0x8f, 0x8b, 0xed, 0x53, 0x9f, 0x2e, 0x5f, 0xbe, 0xb5, 0x7c, 0xee, 0xe6, 0x30, 0x96, 0x85, 0x4a,
	0xf4, 0x32, 0x84, 0x0d, 0x62, 0x35, 0x8c, 0xba, 0x28, 0x52, 0x8f, 0x95, 0x3d, 0xfd, 0x37, 0x47,
	0xd6, 0x96, 0x40, 0x33, 0x10, 0x64, 0x54, 0x59, 0x5b, 0xc8, 0xbc, 0x45, 0xa7, 0xa2, 0x68, 0x47,
	0x38, 0xa3, 0x1e, 0x2a, 0x3c, 0x3c, 0x2b, 0xb9, 0xc9, 0xd2, 0xca, 0x5d, 0x5a, 0xc8, 0xb8, 0x2e,
	0x7c, 0x47, 0x02, 0xc8, 0x2f, 0xe9, 0x25, 0x9d, 0xb5, 0x29, 0xbf, 0x2d, 0x01, 0x0d, 0x41, 0xcc,
	0xd0, 0x1a, 0x16, 0x39, 0x6c, 0x90, 0xa3, 0xea, 0x12, 0xa7, 0x85, 0xec, 0x7d, 0x85, 0x06, 0x01,
	0x54, 0x73, 0x5a, 0x2d, 0x6b, 0x33, 0xc4, 0x38, 0xce, 0x52, 0x1d, 0x91, 0x3d, 0x6f, 0xd0, 0xeb,
	0x10, 0xa9, 0x28, 0x96, 0x32, 0xaf, 0x98, 0xbc, 0x32, 0xf7, 0x3c, 0x2e, 0x7c, 0xaf, 0xec, 0x48,
	0xe1, 0x0f, 0x25, 0x5a, 0x92, 0xf8, 0xe2, 0x51, 0xad, 0xd0, 0x71, 0x26, 0xb0, 0xda, 0x99, 0x45,
	0xcd, 0x14, 0x44, 0x96, 0xd9, 0x33, 0x7d, 0xa7, 0x6b, 0x86, 0xc5, 0xf9, 0x28, 0xb3, 0x67, 0x4a,
	0x91, 0x86, 0x49, 0x0c, 0x26, 0x1f, 0xe4, 0x14, 0xb1, 0xd7, 0xf4, 0x37, 0x5d, 0x31, 0xcd, 0x77,
	0x35, 0xa3, 0xc2, 0x1b, 0x80, 0xec, 0xac, 0xf1, 0xd3, 0x10, 0x9e, 0x33, 0xaa, 0x32, 0x31, 0x75,
	0x34, 0x00, 0x7d, 0x0d, 0xa3, 0x2a, 0x10, 0xd1, 0x47, 0xfc, 0x79, 0x1f, 0x44, 0x4a, 0x3a, 0x31,
	0x66, 0x2c, 0xa2, 0xaf, 0xe9, 0xa5, 0xe3, 0x10, 0xd6, 0x74, 0x62, 0x1c, 0x22, 0x76, 0x71, 0x4c,
	0x76, 0x5a, 0xc9, 0xa7, 0x79, 0x82, 0x1f, 0xd5, 0x43, 0xb1, 0x6c, 0xef, 0xa7, 0x80, 0x0c, 0xf2,
	0x4e, 0x43, 0x35, 0x08, 0x67, 0x6d, 0x54, 0x76, 0xd6, 0xd4, 0x39, 0xf7, 0xb0, 0xf1, 0x03, 0x85,
	0xde, 0x84, 0x90, 0x5a, 0xd7, 0x1b, 0x96, 0x19, 0x0f, 0x32, 0x8e, 0x3f, 0xdf, 0x2d, 0xf2, 0x36,
	0xe0, 0x74, 0x81, 0x89, 0xe4, 0xeb, 0x96, 0xd1, 0x94, 0x85, 0x3c, 0xed, 0xba, 0x5a, 0xc3, 0x62,
	0xaa, 0x42, 0xbc, 0xeb, 0x8a, 0x25, 0xb5, 0x5b, 0xd6, 0x2a, 0x84, 0xb5, 0xa9, 0xa8, 0xcc, 0x9e,
	0xd1, 0xeb, 0x10, 0x56, 0x74, 0x95, 0x8e, 0x27, 0xac, 0x4d, 0xad, 0xaa, 0x6b, 0x5e, 0x0e, 0x2b,
	0xba, 0x7a, 0x44, 0xad, 0x1f, 0xd5, 0x04, 0x85, 0xb1, 0x6c, 0x8b, 0xa1, 0x57, 0x21, 0x64, 0x36,
	0x6b, 0xf3, 0x5a, 0x35, 0x1e, 0x1b, 0x92, 0x52, 0x9b, 0x32, 0xcf, 0x76, 0x43, 0x3e, 0xa3, 0x97,
	0x67, 0xd8, 0x66, 0x59, 0x08, 0x25, 0xc6, 0x21, 0xe6, 0xf1, 0x82, 0x66, 0xe8, 0x18, 0x69, 0xda,
	0x19, 0x3a, 0x46, 0x58, 0x77, 0xf5, 0x94, 0x4e, 0x51, 0x02, 0x27, 0x02, 0x2f, 0x49, 0xb8, 0x13,
	0x80, 0xf0, 0xa4, 0xae, 0x16, 0xea, 0x47, 0x35, 0xb4, 0x6f, 0x55, 0xfd, 0xe9, 0x99, 0x27, 0xce,
	0xbc, 0xad, 0xf6, 0xcc, 0x20, 0x54, 0xf3, 0xc6, 0xbf, 0x15, 0x82, 0x96, 0x32, 0x5f, 0x25, 0x82,
	0x90, 0x7c, 0x81, 0x0e, 0x3a, 0x45, 0x88, 0x77, 0xab, 0xd1, 0x6e, 0x6e, 0x0a, 0x54, 0xe9, 0xc3,
	0x4c, 0x42, 0xe4, 0x47, 0x14, 0x9c, 0xad, 0x10, 0x64, 0x87, 0x52, 0x70, 0x98, 0x2f, 0xe8, 0xb4,
	0xc0, 0x87, 0x23, 0x41, 0x5f, 0xb1, 0xa2, 0xd9, 0xb4, 0xcb, 0x53, 0x98, 0x67, 0xd3, 0xae, 0x3d,
	0x13, 0x10, 0x34, 0x2d, 0xa2, 0x9b, 0xf1, 0x48, 0xef, 0xce, 0x66, 0x13, 0x46, 0xe6, 0x22, 0x34,
	0xe8, 0x1e, 0x68, 0xeb, 0x0a, 0x7a, 0x01, 0x36, 0x08, 0xef, 0xec, 0x01, 0x26, 0xc8, 0x78, 0x21,
	0x1a, 0xec, 0xf7, 0x7d, 0x84, 0x45, 0xe6, 0x12, 0xf8, 0x10, 0x6c, 0xb4, 0x81, 0x71, 0x5d, 0x8e,
	0x4b, 0xd2, 0xba, 0x5d, 0xc2, 0x1f, 0x07, 0x20, 0xc6, 0xa9, 0x65, 0xb2, 0xa3, 0x7e, 0x08, 0x42,
	0x0c, 0xb4, 0xad, 0x6c, 0x5f, 0x57, 0x5a, 0xba, 0x82, 0xe9, 0x1f, 0x33, 0x29, 0x91, 0x33, 0xae,
	0x02, 0xbd, 0x69, 0x0f, 0xed, 0x01, 0xa6, 0x2b, 0xe3, 0x57, 0x17, 0x3d, 0x20, 0x42, 0x15, 0x57,
	0x40, 0x23, 0xef, 0x31, 0xd0, 0x2b, 0xf2, 0x41, 0x4f, 0xe4, 0x13, 0x2f, 0x01, 0xb8, 0xfa, 0xbc,
	0x92, 0xc1, 0x5e, 0x39, 0x9b, 0x87, 0x08, 0x0b, 0x15, 0x79, 0x87, 0xd1, 0x4f, 0xad, 0x57, 0xc8,
	0x92, 0x90, 0xe4, 0x0b, 0x5a, 0xfa, 0x35, 0x11, 0x50, 0x26, 0xee, 0x37, 0xf8, 0x8e, 0x14, 0xfe,
	0x21, 0xc4, 0x72, 0xa4, 0xea, 0x98, 0x89, 0xbb, 0x75, 0x85, 0x3b, 0xe7, 0xd4, 0x8b, 0xed, 0x10,
	0xa2, 0x19, 0x2b, 0x54, 0x84, 0x87, 0x62, 0x85, 0x31, 0x44, 0x78, 0xe8, 0x0a, 0x39, 0xb6, 0x87,
	0xd7, 0x14, 0x2e, 0x2c, 0x56, 0xf8, 0xaf, 0x01, 0xe8, 0x9f, 0x52, 0xeb, 0xc7, 0xd6, 0x54, 0xea,
	0xac, 0x23, 0x10, 0x78, 0x78, 0x00, 0x79, 0xe4, 0xc7, 0x8e, 0x77, 0x12, 0x16, 0x92, 0x54, 0x47,
	0x8d, 0x26, 0x69, 0x4c, 0x8c, 0x54, 0x1e, 0x1d, 0x6b, 0x3e, 0x21, 0xc6, 0x26, 0xbc, 0x5f, 0x12,
	0x58, 0x16, 0x92, 0x28, 0x05, 0x91, 0x5a, 0x9d, 0x7d, 0x45, 0x8e, 0xb1, 0xf2, 0x1e, 0xcc, 0x6e,
	0xf8, 0xa6, 0x95, 0x74, 0xde, 0xc9, 0xce, 0x93, 0x63, 0x2d, 0x23, 0x66, 0x87, 0x6e, 0xd6, 0x32,
	0x8f, 0xb4, 0x96, 0xf1, 0x58, 0xcb, 0xb0, 0xb2, 0xb1, 0xda, 0x5a, 0xc6, 0xb1, 0x96, 0xc1, 0x07,
	0x20, 0x4a, 0xe3, 0xc6, 0x8f, 0xd9, 0x7e, 0x08, 0x56, 0xd5, 0xfa, 0x31, 0xfb, 0x64, 0x74, 0x1d,
	0xa7, 0xa8, 0x94, 0xcc, 0xb7, 0x8f, 0xbc, 0x0c, 0x51, 0xa7, 0x7e, 0xa3, 0x08, 0xf4, 0x17, 0x4b,
	0xc5, 0xfc, 0xc0, 0x53, 0x68, 0x03, 0x44, 0xb2, 0x53, 0xa5, 0x03, 0x87, 0x8e, 0x14, 0x8a, 0x03,
	0x12, 0xda, 0x08, 0x51, 0xbe, 0x2a, 0xcd, 0xcd, 0x0e, 0x04, 0x50, 0x18, 0xfa, 0xf2, 0xc5, 0xdc,
	0x40, 0x7f, 0xe6, 0x46, 0x1c, 0x36, 0x65, 0xb9, 0x9d, 0x69, 0x6e, 0x06, 0x9d, 0x95, 0x60, 0x03,
	0xfb, 0xa4, 0x31, 0x0b, 0x75, 0x93, 0x18, 0x16, 0xea, 0xfd, 0xf1, 0x93, 0xe8, 0xbd, 0x05, 0xef,
	0x7b, 0xff, 0x5f, 0x5f, 0x5d, 0x0c, 0x3c, 0x87, 0x53, 0xa3, 0x62, 0xeb, 0x73, 0x15, 0xc5, 0x5c,
	0x9c, 0xd7, 0x14, 0xa3, 0x62, 0xbf, 0x19, 0x15, 0xf1, 0x54, 0x99, 0xdd, 0x09, 0x69, 0x04, 0xfd,
	0xc2, 0xc1, 0x92, 0x23, 0x55, 0x62, 0x11, 0x84, 0xbb, 0x19, 0xe2, 0x97, 0x01, 0x4f, 0x18, 0x4c,
	0x85, 0x19, 0xa6, 0x60, 0xdc, 0xc0, 0xcc, 0xe9, 0x15, 0xc5, 0x22, 0xdf, 0x3a, 0x30, 0xfc, 0x86,
	0x63, 0x1d, 0x58, 0x1a, 0xcc, 0x2e, 0xc5, 0x72, 0x55, 0x82, 0xcd, 0x1c, 0xcb, 0x0c, 0xa9, 0x92,
	0xb2, 0x35, 0x59, 0xad, 0xa2, 0xae, 0xb5, 0xc1, 0xbe, 0x0a, 0x49, 0xec, 0xea, 0x09, 0x9a, 0xd1,
	0x11, 0xef, 0x67, 0xb0, 0x9e, 0xc7, 0x7b, 0x7a, 0xc3, 0x32, 0x6d, 0x08, 0x14, 0xd9, 0x15, 0x09,
	0x90, 0x17, 0x59, 0xb6, 0xc9, 0xea, 0xcb, 0x13, 0x4a, 0xdc, 0x38, 0x43, 0xb5, 0x0f, 0xa7, 0xfd,
	0xa2, 0xe2, 0xe6, 0x29, 0xb0, 0xdf, 0x4a, 0xb0, 0x6d, 0xc6, 0x32, 0x1a, 0x65, 0xcb, 0x8d, 0x59,
	0x56, 0x31, 0x89, 0x89, 0x7a, 0x27, 0x29, 0xf1, 0x6c, 0x2f, 0xf8, 0x3c, 0x68, 0xaf, 0x30, 0x78,
	0xfb, 0xf1, 0x58, 0x17, 0x78, 0x26, 0xc7, 0xe0, 0x46, 0x8d, 0x81, 0xa0, 0x08, 0x4f, 0x49, 0x10,
	0xa3, 0x27, 0xdb, 0x3e, 0x78, 0x3d, 0x4b, 0x40, 0xa2, 0xe7, 0x0e, 0x9c, 0x61, 0x88, 0xf6, 0xe2,
	0xdd, 0x5d, 0x10, 0xb1, 0x3a, 0xe2, 0x39, 0x75, 0xe7, 0x25, 0xd8, 0xc4, 0x70, 0xb8, 0xdc, 0xfa,
	0xb6, 0x21, 0x72, 0xca, 0x9c, 0x03, 0x68, 0xa4, 0x27, 0x20, 0x27, 0x40, 0xe8, 0x63, 0x09, 0xb6,
	0x30, 0x40, 0xbc, 0x0a, 0x64, 0x9b, 0xa2, 0xda, 0x3d, 0xd3, 0xbb, 0xe3, 0x17, 0x72, 0x3e, 0x82,
	0x34, 0xc1, 0x30, 0xbd, 0x80, 0x47, 0x7b, 0x62, 0xaa, 0xac, 0x02, 0x40, 0x83, 0x75, 0x49, 0x82,
	0x81, 0x49, 0x5d, 0x5d, 0x3f, 0xdb, 0xfd, 0xcc, 0x64, 0xf8, 0x07, 0x0c, 0xd9, 0x18, 0xde, 0xdb,
	0x05, 0x99, 0xa2, 0xab, 0x6b, 0xd9, 0xfe, 0x81, 0x04, 0x1b, 0x5d, 0x58, 0x3e, 0x53, 0x98, 0xf2,
	0x01, 0x89, 0x67, 0x71, 0x8c, 0xe1, 0xda, 0x83, 0x87, 0xfd, 0xe1, 0xa2, 0xf6, 0xcf, 0x4a, 0x00,
	0x14, 0x91, 0x20, 0xb7, 0x1f, 0xf7, 0xfd, 0xc5, 0xc8, 0xc6, 0xb2, 0xab, 0x17, 0x16, 0x97, 0xe1,
	0x76, 0xd2, 0x6c, 0x3e, 0x7d, 0x47, 0x49, 0xab, 0x78, 0xcc, 0x8b, 0x76, 0x17, 0xa3, 0xb3, 0x9a,
	0x1d, 0xa3, 0xee, 0xfc, 0x16, 0x43, 0x9d, 0x9f, 0x1e, 0xe3, 0xa7, 0x0a, 0xb0, 0x81, 0xdd, 0x13,
	0xa3, 0x73, 0x36, 0x18, 0xd1, 0x7a, 0x77, 0x77, 0xbd, 0x75, 0x70, 0x87, 0xcc, 0x27, 0x8b, 0xc7,
	0x6d, 0xbf, 0x1f, 0x49, 0xb0, 0xc5, 0x9e, 0x70, 0x05, 0xad, 0x67, 0x49, 0x4d, 0xf7, 0xc3, 0xeb,
	0x61, 0x3f, 0x53, 0x33, 0x27, 0xb6, 0xdd, 0x8d, 0xf7, 0xf4, 0x44, 0x66, 0xba, 0x10, 0x2e, 0x4b,
	0xb0, 0xd9, 0x81, 0xe6, 0x27, 0x77, 0xf6, 0xe6, 0x84, 0xaf, 0x5d, 0xbe, 0x7a, 0xb1, 0x37, 0x7d,
	0x14, 0x14, 0x0d, 0xd9, 0xaf, 0x25, 0x40, 0xf6, 0xf5, 0xe9, 0xfa, 0x2a, 0xc1, 0xb0, 0x9f, 0x1b,
	0x59, 0x1e, 0x31, 0x9b, 0xed, 0xdd, 0x8a, 0x67, 0x45, 0xd1, 0xd2, 0xe2, 0xae, 0xcd, 0x2d, 0x08,
	0x57, 0x24, 0xd8, 0xec, 0xa0, 0xf3, 0x13, 0x35, 0x7b, 0x73, 0xc2, 0xd7, 0x2e, 0x5f, 0xc7, 0xd0,
	0x03, 0xcc, 0x65, 0xfe, 0xcf, 0x24, 0x08, 0xe5, 0x97, 0xd8, 0xed, 0x56, 0xd7, 0x69, 0xc9, 0xbd,
	0x0e, 0xec, 0x5e, 0x17, 0xc4, 0x3d, 0x17, 0xde, 0xcb, 0x00, 0xed, 0xc2, 0x3b, 0xbb, 0x00, 0x22,
	0xcc, 0x2e, 0x45, 0xf1, 0xa1, 0x04, 0x9b, 0x66, 0x74, 0x52, 0x56, 0x95, 0xaa, 0xf8, 0x78, 0xf5,
	0x93, 0xb8, 0xdd, 0x3e, 0x3f, 0x82, 0xf1, 0x0b, 0x0c, 0x4c, 0xba, 0x6b, 0x05, 0x37, 0x57, 0x99,
	0x9f, 0x90, 0x46, 0xb2, 0xdb, 0xbe, 0xf8, 0xef, 0xe0, 0x53, 0x5f, 0xdc, 0x1f, 0x94, 0xfe, 0x79,
	0x7f, 0x50, 0xfa, 0xcf, 0xfd, 0x41, 0xe9, 0x27, 0x7d, 0x8a, 0xae, 0xce, 0x87, 0xd8, 0x7f, 0xed,
	0xf6, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x23, 0x15, 0x99, 0xa1, 0x1e, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackendManagerClient is the client API for BackendManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackendManagerClient interface {
	ModelsInsert(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Model, error)
	ModelsDelete(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*Model, error)
	ModelsUpdate(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Empty, error)
	ModelsSelectAll(ctx context.Context, in *TypeIden, opts ...grpc.CallOption) (*ModelArray, error)
	ModelsSelectByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*Model, error)
	StructsSelectAllBases(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NameArray, error)
	LinksInsert(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Link, error)
	LinksSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LinkArray, error)
	LinksDeleteBySymbol(ctx context.Context, in *SymbolID, opts ...grpc.CallOption) (*Link, error)
	ApisSelectByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*ApiInfo, error)
	ApisSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ApiInfoArray, error)
	ApisInsert(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*ApiInfo, error)
	ApisDeleteByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*ApiInfo, error)
	StepsInsert(ctx context.Context, in *StepReqs, opts ...grpc.CallOption) (*Empty, error)
	StepsDelete(ctx context.Context, in *DelStepReqs, opts ...grpc.CallOption) (*Empty, error)
	OperStepsSelectTemp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OperStepArray, error)
	OperStepsInsert(ctx context.Context, in *OperStep, opts ...grpc.CallOption) (*OperStep, error)
	DaoGroupsSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DaoGroupArray, error)
	DaoGroupsInsert(ctx context.Context, in *DaoGroup, opts ...grpc.CallOption) (*DaoGroup, error)
	Export(ctx context.Context, in *ExpOptions, opts ...grpc.CallOption) (*UrlResp, error)
	SpecialSymbols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SymbolsResp, error)
}

type backendManagerClient struct {
	cc *grpc.ClientConn
}

func NewBackendManagerClient(cc *grpc.ClientConn) BackendManagerClient {
	return &backendManagerClient{cc}
}

func (c *backendManagerClient) ModelsInsert(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Model, error) {
	out := new(Model)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ModelsInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ModelsDelete(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*Model, error) {
	out := new(Model)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ModelsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ModelsUpdate(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ModelsUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ModelsSelectAll(ctx context.Context, in *TypeIden, opts ...grpc.CallOption) (*ModelArray, error) {
	out := new(ModelArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ModelsSelectAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ModelsSelectByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*Model, error) {
	out := new(Model)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ModelsSelectByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) StructsSelectAllBases(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NameArray, error) {
	out := new(NameArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/StructsSelectAllBases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) LinksInsert(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Link, error) {
	out := new(Link)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/LinksInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) LinksSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LinkArray, error) {
	out := new(LinkArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/LinksSelectAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) LinksDeleteBySymbol(ctx context.Context, in *SymbolID, opts ...grpc.CallOption) (*Link, error) {
	out := new(Link)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/LinksDeleteBySymbol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ApisSelectByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*ApiInfo, error) {
	out := new(ApiInfo)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ApisSelectByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ApisSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ApiInfoArray, error) {
	out := new(ApiInfoArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ApisSelectAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ApisInsert(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*ApiInfo, error) {
	out := new(ApiInfo)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ApisInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) ApisDeleteByName(ctx context.Context, in *NameID, opts ...grpc.CallOption) (*ApiInfo, error) {
	out := new(ApiInfo)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/ApisDeleteByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) StepsInsert(ctx context.Context, in *StepReqs, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/StepsInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) StepsDelete(ctx context.Context, in *DelStepReqs, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/StepsDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) OperStepsSelectTemp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*OperStepArray, error) {
	out := new(OperStepArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/OperStepsSelectTemp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) OperStepsInsert(ctx context.Context, in *OperStep, opts ...grpc.CallOption) (*OperStep, error) {
	out := new(OperStep)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/OperStepsInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) DaoGroupsSelectAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DaoGroupArray, error) {
	out := new(DaoGroupArray)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/DaoGroupsSelectAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) DaoGroupsInsert(ctx context.Context, in *DaoGroup, opts ...grpc.CallOption) (*DaoGroup, error) {
	out := new(DaoGroup)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/DaoGroupsInsert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) Export(ctx context.Context, in *ExpOptions, opts ...grpc.CallOption) (*UrlResp, error) {
	out := new(UrlResp)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendManagerClient) SpecialSymbols(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SymbolsResp, error) {
	out := new(SymbolsResp)
	err := c.cc.Invoke(ctx, "/backend.manager.service.v1.BackendManager/SpecialSymbols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendManagerServer is the server API for BackendManager service.
type BackendManagerServer interface {
	ModelsInsert(context.Context, *Model) (*Model, error)
	ModelsDelete(context.Context, *NameID) (*Model, error)
	ModelsUpdate(context.Context, *Model) (*Empty, error)
	ModelsSelectAll(context.Context, *TypeIden) (*ModelArray, error)
	ModelsSelectByName(context.Context, *NameID) (*Model, error)
	StructsSelectAllBases(context.Context, *Empty) (*NameArray, error)
	LinksInsert(context.Context, *Link) (*Link, error)
	LinksSelectAll(context.Context, *Empty) (*LinkArray, error)
	LinksDeleteBySymbol(context.Context, *SymbolID) (*Link, error)
	ApisSelectByName(context.Context, *NameID) (*ApiInfo, error)
	ApisSelectAll(context.Context, *Empty) (*ApiInfoArray, error)
	ApisInsert(context.Context, *ApiInfo) (*ApiInfo, error)
	ApisDeleteByName(context.Context, *NameID) (*ApiInfo, error)
	StepsInsert(context.Context, *StepReqs) (*Empty, error)
	StepsDelete(context.Context, *DelStepReqs) (*Empty, error)
	OperStepsSelectTemp(context.Context, *Empty) (*OperStepArray, error)
	OperStepsInsert(context.Context, *OperStep) (*OperStep, error)
	DaoGroupsSelectAll(context.Context, *Empty) (*DaoGroupArray, error)
	DaoGroupsInsert(context.Context, *DaoGroup) (*DaoGroup, error)
	Export(context.Context, *ExpOptions) (*UrlResp, error)
	SpecialSymbols(context.Context, *Empty) (*SymbolsResp, error)
}

func RegisterBackendManagerServer(s *grpc.Server, srv BackendManagerServer) {
	s.RegisterService(&_BackendManager_serviceDesc, srv)
}

func _BackendManager_ModelsInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Model)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ModelsInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ModelsInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ModelsInsert(ctx, req.(*Model))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ModelsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ModelsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ModelsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ModelsDelete(ctx, req.(*NameID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ModelsUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Model)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ModelsUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ModelsUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ModelsUpdate(ctx, req.(*Model))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ModelsSelectAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TypeIden)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ModelsSelectAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ModelsSelectAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ModelsSelectAll(ctx, req.(*TypeIden))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ModelsSelectByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ModelsSelectByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ModelsSelectByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ModelsSelectByName(ctx, req.(*NameID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_StructsSelectAllBases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).StructsSelectAllBases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/StructsSelectAllBases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).StructsSelectAllBases(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_LinksInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Link)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).LinksInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/LinksInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).LinksInsert(ctx, req.(*Link))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_LinksSelectAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).LinksSelectAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/LinksSelectAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).LinksSelectAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_LinksDeleteBySymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SymbolID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).LinksDeleteBySymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/LinksDeleteBySymbol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).LinksDeleteBySymbol(ctx, req.(*SymbolID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ApisSelectByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ApisSelectByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ApisSelectByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ApisSelectByName(ctx, req.(*NameID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ApisSelectAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ApisSelectAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ApisSelectAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ApisSelectAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ApisInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ApisInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ApisInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ApisInsert(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_ApisDeleteByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).ApisDeleteByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/ApisDeleteByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).ApisDeleteByName(ctx, req.(*NameID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_StepsInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepReqs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).StepsInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/StepsInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).StepsInsert(ctx, req.(*StepReqs))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_StepsDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelStepReqs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).StepsDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/StepsDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).StepsDelete(ctx, req.(*DelStepReqs))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_OperStepsSelectTemp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).OperStepsSelectTemp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/OperStepsSelectTemp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).OperStepsSelectTemp(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_OperStepsInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperStep)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).OperStepsInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/OperStepsInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).OperStepsInsert(ctx, req.(*OperStep))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_DaoGroupsSelectAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).DaoGroupsSelectAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/DaoGroupsSelectAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).DaoGroupsSelectAll(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_DaoGroupsInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DaoGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).DaoGroupsInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/DaoGroupsInsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).DaoGroupsInsert(ctx, req.(*DaoGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).Export(ctx, req.(*ExpOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendManager_SpecialSymbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendManagerServer).SpecialSymbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backend.manager.service.v1.BackendManager/SpecialSymbols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendManagerServer).SpecialSymbols(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _BackendManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "backend.manager.service.v1.BackendManager",
	HandlerType: (*BackendManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ModelsInsert",
			Handler:    _BackendManager_ModelsInsert_Handler,
		},
		{
			MethodName: "ModelsDelete",
			Handler:    _BackendManager_ModelsDelete_Handler,
		},
		{
			MethodName: "ModelsUpdate",
			Handler:    _BackendManager_ModelsUpdate_Handler,
		},
		{
			MethodName: "ModelsSelectAll",
			Handler:    _BackendManager_ModelsSelectAll_Handler,
		},
		{
			MethodName: "ModelsSelectByName",
			Handler:    _BackendManager_ModelsSelectByName_Handler,
		},
		{
			MethodName: "StructsSelectAllBases",
			Handler:    _BackendManager_StructsSelectAllBases_Handler,
		},
		{
			MethodName: "LinksInsert",
			Handler:    _BackendManager_LinksInsert_Handler,
		},
		{
			MethodName: "LinksSelectAll",
			Handler:    _BackendManager_LinksSelectAll_Handler,
		},
		{
			MethodName: "LinksDeleteBySymbol",
			Handler:    _BackendManager_LinksDeleteBySymbol_Handler,
		},
		{
			MethodName: "ApisSelectByName",
			Handler:    _BackendManager_ApisSelectByName_Handler,
		},
		{
			MethodName: "ApisSelectAll",
			Handler:    _BackendManager_ApisSelectAll_Handler,
		},
		{
			MethodName: "ApisInsert",
			Handler:    _BackendManager_ApisInsert_Handler,
		},
		{
			MethodName: "ApisDeleteByName",
			Handler:    _BackendManager_ApisDeleteByName_Handler,
		},
		{
			MethodName: "StepsInsert",
			Handler:    _BackendManager_StepsInsert_Handler,
		},
		{
			MethodName: "StepsDelete",
			Handler:    _BackendManager_StepsDelete_Handler,
		},
		{
			MethodName: "OperStepsSelectTemp",
			Handler:    _BackendManager_OperStepsSelectTemp_Handler,
		},
		{
			MethodName: "OperStepsInsert",
			Handler:    _BackendManager_OperStepsInsert_Handler,
		},
		{
			MethodName: "DaoGroupsSelectAll",
			Handler:    _BackendManager_DaoGroupsSelectAll_Handler,
		},
		{
			MethodName: "DaoGroupsInsert",
			Handler:    _BackendManager_DaoGroupsInsert_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _BackendManager_Export_Handler,
		},
		{
			MethodName: "SpecialSymbols",
			Handler:    _BackendManager_SpecialSymbols_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "backend/api/api.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NumberID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NameID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TypeIden) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeIden) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NameArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Prop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Props) > 0 {
		for _, msg := range m.Props {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Methods) > 0 {
		for _, s := range m.Methods {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if m.X != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Y))
	}
	if m.Width != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModelArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Models) > 0 {
		for _, msg := range m.Models {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaoGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Category) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	if len(m.Implement) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Implement)))
		i += copy(dAtA[i:], m.Implement)
	}
	if len(m.Interfaces) > 0 {
		for _, msg := range m.Interfaces {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaoGroupArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoGroupArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Implement) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Implement)))
		i += copy(dAtA[i:], m.Implement)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaoInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaoInterface) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Category) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExpOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.RoutePrefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RoutePrefix)))
		i += copy(dAtA[i:], m.RoutePrefix)
	}
	if m.IsMicoServ {
		dAtA[i] = 0x20
		i++
		if m.IsMicoServ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Database != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Database.Size()))
		n1, err := m.Database.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UrlResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrlResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.OperKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OperKey)))
		i += copy(dAtA[i:], m.OperKey)
	}
	if len(m.Requires) > 0 {
		for _, s := range m.Requires {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Inputs) > 0 {
		for k, _ := range m.Inputs {
			dAtA[i] = 0x2a
			i++
			v := m.Inputs[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Outputs) > 0 {
		for _, s := range m.Outputs {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.ApiName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ApiName)))
		i += copy(dAtA[i:], m.ApiName)
	}
	if m.Symbol != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Symbol))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ApiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.Table) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if len(m.Params) > 0 {
		for k, _ := range m.Params {
			dAtA[i] = 0x22
			i++
			v := m.Params[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Route) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Route)))
		i += copy(dAtA[i:], m.Route)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x42
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ApiInfoArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiInfoArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperStepArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperStepArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintApi(dAtA, i, uint64(v))
		}
	}
	if len(m.Names) > 0 {
		for k, _ := range m.Names {
			dAtA[i] = 0x12
			i++
			v := m.Names[k]
			mapSize := 1 + sovApi(uint64(k)) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepReqs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepReqs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Index))
	}
	if m.OperStep != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OperStep.Size()))
		n2, err := m.OperStep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DelStepReqs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelStepReqs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ApiName)))
		i += copy(dAtA[i:], m.ApiName)
	}
	if m.StepId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StepId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SymbolID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SymbolID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Symbol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Symbol)))
		i += copy(dAtA[i:], m.Symbol)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Symbol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Symbol)))
		i += copy(dAtA[i:], m.Symbol)
	}
	if len(m.Mname1) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mname1)))
		i += copy(dAtA[i:], m.Mname1)
	}
	if m.Mnumber1 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mnumber1))
	}
	if len(m.Mname2) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mname2)))
		i += copy(dAtA[i:], m.Mname2)
	}
	if m.Mnumber2 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mnumber2))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LinkArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, msg := range m.Links {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NumberID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NameID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TypeIden) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NameArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Methods) > 0 {
		for _, s := range m.Methods {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.X != 0 {
		n += 1 + sovApi(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovApi(uint64(m.Y))
	}
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModelArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Models) > 0 {
		for _, e := range m.Models {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Implement)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for _, e := range m.Interfaces {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoGroupArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Implement)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaoInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RoutePrefix)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsMicoServ {
		n += 2
	}
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrlResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.OperKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Requires) > 0 {
		for _, s := range m.Requires {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for k, v := range m.Inputs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Outputs) > 0 {
		for _, s := range m.Outputs {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ApiName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Symbol != 0 {
		n += 1 + sovApi(uint64(m.Symbol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Params) > 0 {
		for k, v := range m.Params {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ApiInfoArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperStepArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Names) > 0 {
		for k, v := range m.Names {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepReqs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovApi(uint64(m.Index))
	}
	if m.OperStep != nil {
		l = m.OperStep.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DelStepReqs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StepId != 0 {
		n += 1 + sovApi(uint64(m.StepId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SymbolID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Mname1)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mnumber1 != 0 {
		n += 1 + sovApi(uint64(m.Mnumber1))
	}
	l = len(m.Mname2)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mnumber2 != 0 {
		n += 1 + sovApi(uint64(m.Mnumber2))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LinkArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeIden) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeIden: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeIden: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Prop{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Models", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Models = append(m.Models, &Model{})
			if err := m.Models[len(m.Models)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, &DaoInterface{})
			if err := m.Interfaces[len(m.Interfaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoGroupArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoGroupArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoGroupArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &DaoGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaoInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaoInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaoInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Prop{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Returns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Returns = append(m.Returns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMicoServ", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMicoServ = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &Database{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrlResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrlResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrlResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requires", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requires = append(m.Requires, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inputs == nil {
				m.Inputs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Inputs[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			m.Symbol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Symbol |= SpcSymbol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Params[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Returns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Returns = append(m.Returns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &OperStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiInfoArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiInfoArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiInfoArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &ApiInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperStepArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperStepArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperStepArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &OperStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Names == nil {
				m.Names = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Names[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepReqs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepReqs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepReqs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OperStep == nil {
				m.OperStep = &OperStep{}
			}
			if err := m.OperStep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelStepReqs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelStepReqs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelStepReqs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SymbolID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SymbolID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SymbolID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mname1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mname1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mnumber1", wireType)
			}
			m.Mnumber1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mnumber1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mname2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mname2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mnumber2", wireType)
			}
			m.Mnumber2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mnumber2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)
